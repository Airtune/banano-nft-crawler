import { INanoBlock, TAccount, TBlockHash } from "nano-account-crawler/dist/nano-interfaces";
import { IAssetBlock } from "./interfaces/asset-block";
import { IAtomicSwapConditions } from "./interfaces/atomic-swap-conditions";
import { NanoNode } from 'nano-account-crawler/dist/nano-node';
import { IStatusReturn } from "nano-account-crawler/dist/status-return-interfaces";
export declare class AssetCrawler {
    private _assetChain;
    private _assetRepresentative;
    private _head;
    private _headHeight;
    private _metadataRepresentative;
    private _issuer;
    private _mintBlock;
    private _traceLength;
    activeAtomicSwap: IAssetBlock;
    activeAtomicSwapDelegation: IAssetBlock;
    owner: TAccount;
    locked: boolean;
    lockedInAccount: TAccount;
    constructor(issuer: TAccount, mintBlock: INanoBlock);
    crawl(nanoNode: NanoNode, maxTraceLength?: bigint): Promise<IStatusReturn<void>>;
    initFromCache(assetRepresentative: TAccount, assetChain: IAssetBlock[], initialTraceLength?: bigint): void;
    crawlFromFrontier(nanoNode: NanoNode, maxTraceLength?: bigint): Promise<IStatusReturn<void>>;
    private crawlStep;
    currentAtomicSwapConditions(): IAtomicSwapConditions | undefined;
    findSendAtomicSwapBlock(): IAssetBlock | undefined;
    get assetChain(): IAssetBlock[];
    get frontier(): IAssetBlock;
    get previousFrontier(): IAssetBlock;
    get assetRepresentative(): `ban_${string}` | `nano_${string}`;
    get head(): (undefined | TBlockHash);
    set head(value: TBlockHash);
    get headHeight(): (undefined | number);
    set headHeight(value: number);
    get issuer(): `ban_${string}` | `nano_${string}`;
    get metadataRepresentative(): string;
    get traceLength(): bigint;
    set traceLength(len: bigint);
}
